<?php
/**
 * 
 * Description of MyEnregistrement
 *
 * @todo        gerer le set pour hbtm
 * @todo		unset poour les relations
 * @category    Class
 * @package     ORM
 * @author      bryyce
 * @license     http://www.gnu.org/copyleft/gpl.html GNU General Public License
 * @link        http://www.bryyce.fr/
 */

namespace ORM;
abstract class MyEnregistrement extends Enregistrement{

    const CLE_PRI="id";
    protected static $has_one = array();
    protected static $has_many = array();
    protected static $has_and_belongs_to_many = array();
    protected static $belongs_to = array();
    protected static $relations_elem = array();
    /**
     * Constructeur d'enregistrement
     *
     * @param <int> $_id id de l'objet a chercher dans la BDD si null un objet vide est crÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â©ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â©
     */
    public function __construct($_id=null) {
        $this->initAttributs(self::etiquettes());
        if ($_id != null) {
            $this->lecture($_id);
            //  $this->date = new DateTime($this->date);
        }
    }

	public static function loadRelations(){
        foreach(static::$has_one as $k => $v){   
			if(!array_key_exists('primary_key', static::$has_one[$k]))         
				static::$has_one[$k]['primary_key'] = $k . '_id';
			if(!array_key_exists('class', static::$has_one[$k]))
				static::$has_one[$k]['class'] = 'Model\\'.ucfirst($k); 
        }
        foreach(static::$has_many as $k => $v){
			if(!array_key_exists('primary_key', static::$has_many[$k]))
				static::$has_many[$k]['primary_key'] = $k . '_id';
			if(!array_key_exists('class', static::$has_many[$k]))
				static::$has_many[$k]['class'] = 'Model\\'.ucfirst($k); 
        }
        foreach(static::$has_and_belongs_to_many as $k => $v){
			$class = 'Model\\'.ucfirst(substr($k,0,strlen($k)-1));
			if(!array_key_exists('primary_key', static::$has_and_belongs_to_many[$k]))
				static::$has_and_belongs_to_many[$k]['primary_key'] = substr($k,0,strlen($k)-1) . '_id';
			if(!array_key_exists('class', static::$has_and_belongs_to_many[$k]))
				static::$has_and_belongs_to_many[$k]['class'] = $class; 
			if(array_key_exists('master', static::$has_and_belongs_to_many[$k]) && static::$has_and_belongs_to_many[$k]['master'] == false)	
				static::$has_and_belongs_to_many[$k]['join_table'] =  $class::table() . '_' . static::table();
			else
				static::$has_and_belongs_to_many[$k]['join_table'] = static::table() . '_' . $class::table();
		}
        foreach(static::$belongs_to as $k => $v){  
			if(!array_key_exists('primary_key', static::$belongs_to[$k]))
				static::$belongs_to[$k]['primary_key'] = static::table() . '_id';
			if(!array_key_exists('class', static::$belongs_to[$k]))
				static::$belongs_to[$k]['class'] = 'Model\\'.ucfirst($k); 
		}		
		
	}
    public function etiquettes() {
        return Config::getFields(self::table());
    }

    //	Donne la cle primaire de la table.
    protected static function cle_pri() {
        return self::CLE_PRI;
    }
	
	protected static function getClassName(){
		return strtolower(preg_replace('#([a-zA-Z]+\\\\)+([a-zA-Z]+)#i','$2',get_called_class()));
	}
    /**php 5.3 seulement**/
    //	Donne la table contenant les Departement.
    protected static function table() {
        return Config::getTable(self::getClassName());
    }

    protected static function allBy($cond){
        $table = static::table();
        $res = myPDO::get()->prepare('
			SELECT *
			FROM ' . $table . '
			WHERE ' . $cond
        );
        $records = array();
        // Execution de la requete avec le parametre et lecture du resultat
        if ($res->execute() && $enregistrements = $res->fetchAll(\PDO::FETCH_ASSOC)) {
            // Affectation des valeurs 
            foreach ($enregistrements as $enregistrement) 
                $records[] = new static ($enregistrement[static::CLE_PRI]);
        } 
        return $records;
    }
	
    public static function all(){
        return self::allBy("1=1");        
    }

    public static function first($_params = array()){
        $params = array();
        foreach ($_params as $key => $value)
            $params[] = "$key = '$value'";
        $records = static::allBy(implode(" AND ", $params) . "1=1 ORDER BY id LIMIT 0,1");
        return $records[0];
    }

    public static function last($_params = array()){
        $params = array();
        foreach ($_params as $key => $value)
            $params[] = "$key = '$value'";
        $records = static::allBy(implode(" AND ", $params) . "1=1 ORDER BY id DESC LIMIT 0,1");
        return $records[0];
    }
	
	public static function count($_params = array()){
        $params = array();
        foreach ($_params as $key => $value)
            $params[] = "$key = '$value'";
		$conditions = implode(' AND ', $params);
		$table = static::table();
        $res = myPDO::get()->prepare('
			SELECT 
				COUNT(*) as nb
			FROM 
				'.$table.'
			WHERE 
				'.$conditions
        );
        // Execution de la requete avec le parametre et lecture du resultat
        if ($res->execute() && $enregistrement = $res->fetchAll(\PDO::FETCH_ASSOC))
            return $enregistrement['nb'];
        return 0;
    }

    public static function __callStatic($method, $params)
    {
        if (!preg_match('/^(find|first|last|count)By(\w+)$/', $method, $matches)) {
            throw new \Exception("Call to undefined method {$method}");
        }

        $criteriaKeys = explode('_And_', preg_replace('/([a-z0-9])([A-Z])/', '$1_$2', $matches[2]));
        $criteriaKeys = array_map('strtolower', $criteriaKeys);
        $criteriaValues = array_slice($params, 0, count($criteriaKeys));
        $criteria = array_combine($criteriaKeys, $criteriaValues);

        $method = $matches[1];
        return static::$method($criteria);
    }

    public static function find($_params){
        $params = array();
        foreach ($_params as $key => $value)
            $params[] = "$key = '$value'";
        return static::allBy(implode(" AND ", $params));
    }
    
    
    /// Surcharge de __get pour donner acces aux valeurs sous la forme $e->attribut
    public function __get($_cle /** Nom de la propriete */) {
        if (array_key_exists($_cle, $this->valeurs)) // La propriete demandee est bien une cle du tableau des valeurs
            return $this->valeurs[$_cle] ;
        else if(array_key_exists($_cle, static::$has_one)){
            $id_assoc= static::$has_one[$_cle]['primary_key'];
            $class = static::$has_one[$_cle]['class'];
            if (!array_key_exists($_cle,static::$relations_elem) || static::$relations_elem[$_cle] == null) {
                if ($this->$id_assoc) {
                    static::$relations_elem[$_cle] = $class::AllBy("id = {$this->$id_assoc}");
                    static::$relations_elem[$_cle]= self::$relations_elem[$_cle][0] ;
                }else
                    static::$relations_elem[$_cle] = new $class;
            }
            return static::$relations_elem[$_cle];
        }
        else if(array_key_exists($_cle, static::$has_many)){
            $id_assoc   = static::$has_many[$_cle]['primary_key'];
            $class      = static::$has_many[$_cle]['class'];
            if (!array_key_exists($_cle,static::$relations_elem) || static::$relations_elem[$_cle] == null) {
                if ($this->$id_assoc) 
                    static::$relations_elem[$_cle] = $class::AllBy("id = {$this->$id_assoc}");
                else
                    static::$relations_elem[$_cle] = array();
            }
            return static::$relations_elem[$_cle];
        }
        else if(array_key_exists($_cle, static::$has_and_belongs_to_many)){
			$id_assoc		= static::getClassName() . '_id';
			$id_assoc_2		= static::$has_and_belongs_to_many[$_cle]['primary_key'];
			$_join_table	= static::$has_and_belongs_to_many[$_cle]['join_table'];
            $class			= static::$has_and_belongs_to_many[$_cle]['class'];
			if (!array_key_exists($_cle,static::$relations_elem) || static::$relations_elem[$_cle] == null){
				if($this->id){
					$table = $class::table();
					$res = myPDO::get()->prepare('
						SELECT 
							*
						FROM 
							'.$table.'
						INNER JOIN 
							'.$_join_table.'
						ON 
							'.$_join_table.'.'.$id_assoc_2.' = '.$table.'.'.$class::cle_pri().'
						WHERE 
							'.$_join_table.'.'.$id_assoc.' = '.$this->id
					);
					$records = array();
					// Execution de la requete avec le parametre et lecture du resultat
					if ($res->execute() && $enregistrements = $res->fetchAll(\PDO::FETCH_ASSOC)) {
						// Affectation des valeurs 
						foreach ($enregistrements as $enregistrement) 
							$records[] = new $class ($enregistrement[$class::CLE_PRI]);
					} 

					static::$relations_elem[$_cle] = $records;
				}
				else 
					static::$relations_elem[$_cle] = array();
			}
            return static::$relations_elem[$_cle];            
        }
		else if(array_key_exists($_cle, static::$belongs_to)){
            $id_assoc= static::$belongs_to[$_cle]['primary_key'];
            $class = static::$belongs_to[$_cle]['class'];
            if (!array_key_exists($_cle,static::$relations_elem) || static::$relations_elem[$_cle] == null) {
                $p_k= static::cle_pri();
				if ($this->$p_k) {
                    static::$relations_elem[$_cle] = $class::AllBy("$id_assoc = {$this->$p_k}");
                    static::$relations_elem[$_cle]= self::$relations_elem[$_cle][0] ;
                }else
                    static::$relations_elem[$_cle] = new $class;
            }
            return static::$relations_elem[$_cle];
        }
        throw new \Exception("Attribut '$_cle' inconnu dans '".get_class($this)."'");
    }

    /// Surcharge de __set pour donner acces aux valeurs sous la forme $e->attribut=val
    public function __set($_cle /** Nom de la propriete */, $_val /** Sa nouvelle valeur */) {
        if (array_key_exists($_cle, $this->valeurs)) // La propriete demandee est bien une cle du tableau des valeurs
            return $this->valeurs[$_cle] = $_val ;
		elseif(array_key_exists($_cle, static::$relations_elem))
			return static::$relations_elem[$_cle] = $_val ;
        throw new \Exception("Attribut '$_cle' inconnu dans '".get_class($this)."'");
    }

    /// Surcharge de __isset pour donner acces aux valeurs sous la forme isset($e->attribut)
    public function __isset($_cle /** Nom de la propriete */) {
        if (array_key_exists($_cle, $this->valeurs)) // La propriete demandee est bien une cle du tableau des valeurs
            return isset($this->valeurs[$_cle]);
		elseif(array_key_exists($_cle, static::$relations_elem))
			isset(static::$relations_elem[$_cle]);
        throw new \Exception("Attribut '$_cle' inconnu dans '".get_class($this)."'");
    }

    /// Surcharge de __unset pour donner acces aux valeurs sous la forme unset($e->attribut)
    public function __unset($_cle /** Nom de la propriete */) {
        if (array_key_exists($_cle, $this->valeurs))// La propriete demandee est bien une cle du tableau des valeurs
            return $this->valeurs[$_cle] = null;
		elseif(array_key_exists($_cle, static::$relations_elem))
			unset(static::$relations_elem[$_cle]);
        throw new \Exception("Attribut '$_cle' inconnu dans '" . get_class($this) . "'");
    }
}
?>